#john morris beck 2025 - gplv2 - see gnu.org for license - https://github.com/memesmith0 - https://thefastscrolls.neocities.org
#jysytem.qlfl
#this is a system for quick-learn-field-language that adds a c compiler for a subset of c
#from the quick learn field language to c, that has the exact same performance
#as c - no more, no less. it is just another notation for c.
#later on i will add a javascript compiler for a subset of javascript
#and i will also have some of my own tools that i prefer to have for the shell
#my posix ide/shell
function vish(){system("while :;do vi \"/tmp/.vish_$$\";sh \".vish_$$\";done;")}


#my program that rewrites posix sh synatx while its running and is a posix vm
#awk 'BEGIN{r[0]=0;r[1]=1;r[x]=1;ic=1;while(r[x]){x=substr(ci,ic,1);y=substr(ci,ic+1,1);z=substr(ci,ic+2,1);if(z == "-"){r[x]-=r[y]}; else if(z == "<"){r[x]=r[x]<r[y]}; else if(z == "m"){r[y]=r[x]}; else if(z == "$"){r[x]=system(r[y])}; else if(z == "r"){r[x]=r[r[y]]}; else if(z == "w"){r[r[y]] = r[x]}; else if(z == "i"){getline r[x]}; else if(z == "o"){printf "%s", r[x]}; else if(z == "+"){r[x]=r[x] r[y]}; else if(z == "c"){r[x] = sprintf("%c", r[y])}; else if(z == "#"){r[x] = ord(r[y])}; else if(z == "s"){r[x]=substr(r[x],r[y],1)};else if(z == "x"){ic=-2;ci=r[x]}; ic+=3};};' ci="$1";}

#c compiler
function include(x){return "#include " x "\n"}
fucntion arg(x,y){return x ", " y}
function call(name,args){return name "( " args " )"}
function brace(x){return "{ " x " }"}
function function_call(name,args,body){return concat(call(name,args),brace(body))}
function define(name,args,definition){return "#define " call(name,args) " " definition "\n"}
function type(t,v){return t v}
function line(x){ return x ";"}
function decide(args,body){return function_call("if",args,body)}
function else_decide(args,body){return function_call("else if",args,body)}
function otherwise(body){return "else{ " body " }"}
function c_add(x,y){return "( " x " + " y " )"}
function c_sub(x,y){return "( " x " - " y " )"}
function c_mult(x,y){return "( " x " * " y " )"}
function c_div(x,y){return "( " x " / " y " )"}
function c_mod(x,y){return "( " x " % " y " )"}
function c_bshift_l(x,y){return "( " x " << " y " )"}
function c_bshift_r(x,y){reurn "( " x " >> " y " )"}
function c_not(x,y){return "( !" x " )"}
function c_negate(x,y){return "( -" x " )"}
function c_or(x,y){return "( " x " || " y " )"}
function c_less(x,y){return "( " x " < " y " )"}
function c_greater(x,y){return "( " x " > " y " )"}
function c_leq(x,y){return "( " x " <= " y " )"}
function c_geq(x,y){return "( " x " >= " y " )"}
function c_and(x,y){return "( " x " && " y " )"}
function c_not_equal(x,y){return "( " x " != " y " )"}
function c_equal(x,y){return "( " x " == " y " )"}
function c_b_or(x,y){return "( " x " | " y " )"}
function c_b_and(x,y){return "( " x " & " y " )"}
function c_b_xor(x,y){return "( " x " ^ " y " )"}
function struct(name, body, tail){ return  "struct "  name brace(body) tail ";"}
function enum(name,body){return "enum " name " " body ";"}
function reference(x){return "&" x}
function assign(x,y){return x "=" y}
function float_suffix(x){return x "f"}
function char_literal(x){return "'" x "'"
function post_increment(x){return x "++"}
function post_decrement(x){return x "--"}
function pre_increment(x){return "++" x}
function pre_decrement(x){return "--" x}
function access(x,y){return x "[" y "]"}
function c_string(x,y){return "\"" x "\""}
function ternary(x,y,z){return x " ? " y " : " z}
function case(x,body){return "case " x ": " body};
function default(body){return "default: " body};
function c_break(){ return "break;"}
function c_continue(){ return "continue;"}
function label(name){ return name ": "}
funtion goto(name){ return name }
function c_return(x){return "return " x}
function cast(type,data){return "( ( " type " ) " data " )"}
function dereference(x){return "( *( " x " ) )"}
#need to implement typedef
function initialize_struct(name,type){return "struct " name " " type}
function dot(x,y){return x "." y}
function arrow(x,y){return x "->" y}
function inline_c(x,y,z){return x y z};
#need to defien stuff like ifdef and ifndef and all tha
#function main(){
#your code goes here
#}

#//gcc -O3 -march=native -flto vm.c#license:john morris beck gpl2 @ gnu.org
#//in case i die future design envolves incresasing register space for speedy caching, and replacing
#//malloc and free for mmap an munmap, and make the files be in /dev/shm or fallback to /dev/tmp if shm is unavailable
#//a special naming scheme with guarnteed unique filenames based on timestamp, process id, and a random string from /dev/urandom allows
#//for optional shared memory between vm processes. shared memory is intended to be used immutably where possible else with locks
##include <stdio.h>
##include <stdlib.h>
##include <string.h>
#int main(){int x=0,y=16,z=0,i[16],f[512],*t=f;void* p[16];while(y--){i[y]=1;p[y]=&t;}for(;x<512;t[x++]=getchar());while(1){x=t[1];y=t[2];z=*t;switch(z){case 0:i[x]-=i[y];break;case 1:i[x]=i[x]<i[y];break;case 3:p[y]=p[x];break;case 4:i[y]=i[x];break;case 5:p[y]=*(void**)p[x];break;case 6:*(void**)p[y]=p[x];break;case 7:p[y]=(void*)((char*)(p[y]+(int)i[x]));break;case 8:i[x]?p[y]=malloc(i[x]):free(p[y]);i[x]=(p[y]==NULL);break;case 9:fread(p[y],1,i[y],stdin);break;case 10:fwrite(p[y],1,i[y],stdout);fflush(stdout);break;case 11:exit(0);}t+=3;}}



